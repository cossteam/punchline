// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/signaling/v1/signaling.proto

package signaling

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ICE Connection state from pion/ice/ice.go
type ConnectionState int32

const (
	ConnectionState_NEW          ConnectionState = 0
	ConnectionState_CHECKING     ConnectionState = 1
	ConnectionState_CONNECTED    ConnectionState = 2
	ConnectionState_COMPLETED    ConnectionState = 3
	ConnectionState_FAILED       ConnectionState = 4
	ConnectionState_DISCONNECTED ConnectionState = 5
	ConnectionState_CLOSED       ConnectionState = 6
)

var ConnectionState_name = map[int32]string{
	0: "NEW",
	1: "CHECKING",
	2: "CONNECTED",
	3: "COMPLETED",
	4: "FAILED",
	5: "DISCONNECTED",
	6: "CLOSED",
}

var ConnectionState_value = map[string]int32{
	"NEW":          0,
	"CHECKING":     1,
	"CONNECTED":    2,
	"COMPLETED":    3,
	"FAILED":       4,
	"DISCONNECTED": 5,
	"CLOSED":       6,
}

func (x ConnectionState) String() string {
	return proto.EnumName(ConnectionState_name, int32(x))
}

func (ConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{0}
}

// ICE Candidate types
// See: https://datatracker.ietf.org/doc/html/rfc8445#section-5.1.1
type CandidateType int32

const (
	CandidateType_UNSPECIFIED_CANDIDATE_TYPE CandidateType = 0
	CandidateType_HOST                       CandidateType = 1
	CandidateType_SERVER_REFLEXIVE           CandidateType = 2
	CandidateType_PEER_REFLEXIVE             CandidateType = 3
	CandidateType_RELAY                      CandidateType = 4
)

var CandidateType_name = map[int32]string{
	0: "UNSPECIFIED_CANDIDATE_TYPE",
	1: "HOST",
	2: "SERVER_REFLEXIVE",
	3: "PEER_REFLEXIVE",
	4: "RELAY",
}

var CandidateType_value = map[string]int32{
	"UNSPECIFIED_CANDIDATE_TYPE": 0,
	"HOST":                       1,
	"SERVER_REFLEXIVE":           2,
	"PEER_REFLEXIVE":             3,
	"RELAY":                      4,
}

func (x CandidateType) String() string {
	return proto.EnumName(CandidateType_name, int32(x))
}

func (CandidateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{1}
}

type NetworkType int32

const (
	NetworkType_UNSPECIFIED_NETWORK_TYPE NetworkType = 0
	NetworkType_UDP4                     NetworkType = 1
	NetworkType_UDP6                     NetworkType = 2
	NetworkType_TCP4                     NetworkType = 3
	NetworkType_TCP6                     NetworkType = 4
)

var NetworkType_name = map[int32]string{
	0: "UNSPECIFIED_NETWORK_TYPE",
	1: "UDP4",
	2: "UDP6",
	3: "TCP4",
	4: "TCP6",
}

var NetworkType_value = map[string]int32{
	"UNSPECIFIED_NETWORK_TYPE": 0,
	"UDP4":                     1,
	"UDP6":                     2,
	"TCP4":                     3,
	"TCP6":                     4,
}

func (x NetworkType) String() string {
	return proto.EnumName(NetworkType_name, int32(x))
}

func (NetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{2}
}

// Type of TCP candidate
// See: https://datatracker.ietf.org/doc/html/rfc6544
type TCPType int32

const (
	TCPType_UNSPECIFIED_TCP_TYPE TCPType = 0
	// ACTIVE 主动发起连接
	TCPType_ACTIVE TCPType = 1
	// PASSIVE 监听传入连接
	TCPType_PASSIVE TCPType = 2
	// SIMULTANEOUS_OPEN 同时打开，允许双方同时发起连接
	TCPType_SIMULTANEOUS_OPEN TCPType = 3
)

var TCPType_name = map[int32]string{
	0: "UNSPECIFIED_TCP_TYPE",
	1: "ACTIVE",
	2: "PASSIVE",
	3: "SIMULTANEOUS_OPEN",
}

var TCPType_value = map[string]int32{
	"UNSPECIFIED_TCP_TYPE": 0,
	"ACTIVE":               1,
	"PASSIVE":              2,
	"SIMULTANEOUS_OPEN":    3,
}

func (x TCPType) String() string {
	return proto.EnumName(TCPType_name, int32(x))
}

func (TCPType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{3}
}

type RelayProtocol int32

const (
	RelayProtocol_UNSPECIFIED_RELAY_PROTOCOL RelayProtocol = 0
	RelayProtocol_UDP                        RelayProtocol = 1
	RelayProtocol_TCP                        RelayProtocol = 2
	RelayProtocol_TLS                        RelayProtocol = 3
	RelayProtocol_DTLS                       RelayProtocol = 4
)

var RelayProtocol_name = map[int32]string{
	0: "UNSPECIFIED_RELAY_PROTOCOL",
	1: "UDP",
	2: "TCP",
	3: "TLS",
	4: "DTLS",
}

var RelayProtocol_value = map[string]int32{
	"UNSPECIFIED_RELAY_PROTOCOL": 0,
	"UDP":                        1,
	"TCP":                        2,
	"TLS":                        3,
	"DTLS":                       4,
}

func (x RelayProtocol) String() string {
	return proto.EnumName(RelayProtocol_name, int32(x))
}

func (RelayProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{4}
}

type Message struct {
	Topic       string       `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Data        []byte       `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Candidate   *Candidate   `protobuf:"bytes,3,opt,name=candidate,proto3" json:"candidate,omitempty"`
	Credentials *Credentials `protobuf:"bytes,4,opt,name=credentials,proto3" json:"credentials,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{0}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetCandidate() *Candidate {
	if m != nil {
		return m.Candidate
	}
	return nil
}

func (m *Message) GetCredentials() *Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type PublishRequest struct {
	Topic     string     `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Hostname  string     `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Data      []byte     `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Candidate *Candidate `protobuf:"bytes,4,opt,name=candidate,proto3" json:"candidate,omitempty"`
}

func (m *PublishRequest) Reset()         { *m = PublishRequest{} }
func (m *PublishRequest) String() string { return proto.CompactTextString(m) }
func (*PublishRequest) ProtoMessage()    {}
func (*PublishRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{1}
}
func (m *PublishRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishRequest.Merge(m, src)
}
func (m *PublishRequest) XXX_Size() int {
	return m.Size()
}
func (m *PublishRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishRequest proto.InternalMessageInfo

func (m *PublishRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *PublishRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *PublishRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *PublishRequest) GetCandidate() *Candidate {
	if m != nil {
		return m.Candidate
	}
	return nil
}

type PublishResponse struct {
}

func (m *PublishResponse) Reset()         { *m = PublishResponse{} }
func (m *PublishResponse) String() string { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()    {}
func (*PublishResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{2}
}
func (m *PublishResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishResponse.Merge(m, src)
}
func (m *PublishResponse) XXX_Size() int {
	return m.Size()
}
func (m *PublishResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishResponse proto.InternalMessageInfo

type SubscribeRequest struct {
	Topic    string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{3}
}
func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

func (m *SubscribeRequest) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *SubscribeRequest) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type Credentials struct {
	// ICE username fragment
	Ufrag string `protobuf:"bytes,1,opt,name=ufrag,proto3" json:"ufrag,omitempty"`
	// ICE password
	Pwd string `protobuf:"bytes,2,opt,name=pwd,proto3" json:"pwd,omitempty"`
	// Flag to indicate that the sending peer requests the credentials of the receiving peer
	NeedCreds bool `protobuf:"varint,3,opt,name=need_creds,json=needCreds,proto3" json:"need_creds,omitempty"`
}

func (m *Credentials) Reset()         { *m = Credentials{} }
func (m *Credentials) String() string { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()    {}
func (*Credentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{4}
}
func (m *Credentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Credentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Credentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Credentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Credentials.Merge(m, src)
}
func (m *Credentials) XXX_Size() int {
	return m.Size()
}
func (m *Credentials) XXX_DiscardUnknown() {
	xxx_messageInfo_Credentials.DiscardUnknown(m)
}

var xxx_messageInfo_Credentials proto.InternalMessageInfo

func (m *Credentials) GetUfrag() string {
	if m != nil {
		return m.Ufrag
	}
	return ""
}

func (m *Credentials) GetPwd() string {
	if m != nil {
		return m.Pwd
	}
	return ""
}

func (m *Credentials) GetNeedCreds() bool {
	if m != nil {
		return m.NeedCreds
	}
	return false
}

// The Related Address conveys transport addresses related to the candidate,
// useful for diagnostics and other purposes.
// See: https://datatracker.ietf.org/doc/html/rfc8839#section-5.1
type RelatedAddress struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port    int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *RelatedAddress) Reset()         { *m = RelatedAddress{} }
func (m *RelatedAddress) String() string { return proto.CompactTextString(m) }
func (*RelatedAddress) ProtoMessage()    {}
func (*RelatedAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{5}
}
func (m *RelatedAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelatedAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelatedAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelatedAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelatedAddress.Merge(m, src)
}
func (m *RelatedAddress) XXX_Size() int {
	return m.Size()
}
func (m *RelatedAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_RelatedAddress.DiscardUnknown(m)
}

var xxx_messageInfo_RelatedAddress proto.InternalMessageInfo

func (m *RelatedAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RelatedAddress) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

// An ICE Candidate contains a transport address for a candidate that can be used for connectivity checks.
// See: https://datatracker.ietf.org/doc/html/rfc8839#section-5.1
type Candidate struct {
	// The type of candidate
	Type        CandidateType `protobuf:"varint,1,opt,name=type,proto3,enum=punchline.signaling.CandidateType" json:"type,omitempty"`
	NetworkType NetworkType   `protobuf:"varint,2,opt,name=network_type,json=networkType,proto3,enum=punchline.signaling.NetworkType" json:"network_type,omitempty"`
	TcpType     TCPType       `protobuf:"varint,3,opt,name=tcp_type,json=tcpType,proto3,enum=punchline.signaling.TCPType" json:"tcp_type,omitempty"`
	// An identifier that is equivalent for two candidates that are of the same type, share the same base, and come from the same STUN server.
	Foundation string `protobuf:"bytes,4,opt,name=foundation,proto3" json:"foundation,omitempty"`
	// A positive integer between 1 and 256 that identifies the specific component of the media stream for which this is a candidate.
	Component int32 `protobuf:"varint,5,opt,name=component,proto3" json:"component,omitempty"`
	// A positive integer between 1 and (2**31 - 1).
	Priority int32 `protobuf:"varint,6,opt,name=priority,proto3" json:"priority,omitempty"`
	// The IP address of the candidate.
	Address string `protobuf:"bytes,7,opt,name=address,proto3" json:"address,omitempty"`
	// The port of the candidate.
	Port int32 `protobuf:"varint,8,opt,name=port,proto3" json:"port,omitempty"`
	// The related address conveys transport addresses related to the candidate, useful for diagnostics and other purposes.
	RelatedAddress *RelatedAddress `protobuf:"bytes,9,opt,name=related_address,json=relatedAddress,proto3" json:"related_address,omitempty"`
	// The protocol used between the endpoint and the relay server.
	RelayProtocol RelayProtocol `protobuf:"varint,10,opt,name=relay_protocol,json=relayProtocol,proto3,enum=punchline.signaling.RelayProtocol" json:"relay_protocol,omitempty"`
}

func (m *Candidate) Reset()         { *m = Candidate{} }
func (m *Candidate) String() string { return proto.CompactTextString(m) }
func (*Candidate) ProtoMessage()    {}
func (*Candidate) Descriptor() ([]byte, []int) {
	return fileDescriptor_db5d6de783d80978, []int{6}
}
func (m *Candidate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Candidate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Candidate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Candidate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Candidate.Merge(m, src)
}
func (m *Candidate) XXX_Size() int {
	return m.Size()
}
func (m *Candidate) XXX_DiscardUnknown() {
	xxx_messageInfo_Candidate.DiscardUnknown(m)
}

var xxx_messageInfo_Candidate proto.InternalMessageInfo

func (m *Candidate) GetType() CandidateType {
	if m != nil {
		return m.Type
	}
	return CandidateType_UNSPECIFIED_CANDIDATE_TYPE
}

func (m *Candidate) GetNetworkType() NetworkType {
	if m != nil {
		return m.NetworkType
	}
	return NetworkType_UNSPECIFIED_NETWORK_TYPE
}

func (m *Candidate) GetTcpType() TCPType {
	if m != nil {
		return m.TcpType
	}
	return TCPType_UNSPECIFIED_TCP_TYPE
}

func (m *Candidate) GetFoundation() string {
	if m != nil {
		return m.Foundation
	}
	return ""
}

func (m *Candidate) GetComponent() int32 {
	if m != nil {
		return m.Component
	}
	return 0
}

func (m *Candidate) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Candidate) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Candidate) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Candidate) GetRelatedAddress() *RelatedAddress {
	if m != nil {
		return m.RelatedAddress
	}
	return nil
}

func (m *Candidate) GetRelayProtocol() RelayProtocol {
	if m != nil {
		return m.RelayProtocol
	}
	return RelayProtocol_UNSPECIFIED_RELAY_PROTOCOL
}

func init() {
	proto.RegisterEnum("punchline.signaling.ConnectionState", ConnectionState_name, ConnectionState_value)
	proto.RegisterEnum("punchline.signaling.CandidateType", CandidateType_name, CandidateType_value)
	proto.RegisterEnum("punchline.signaling.NetworkType", NetworkType_name, NetworkType_value)
	proto.RegisterEnum("punchline.signaling.TCPType", TCPType_name, TCPType_value)
	proto.RegisterEnum("punchline.signaling.RelayProtocol", RelayProtocol_name, RelayProtocol_value)
	proto.RegisterType((*Message)(nil), "punchline.signaling.Message")
	proto.RegisterType((*PublishRequest)(nil), "punchline.signaling.PublishRequest")
	proto.RegisterType((*PublishResponse)(nil), "punchline.signaling.PublishResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "punchline.signaling.SubscribeRequest")
	proto.RegisterType((*Credentials)(nil), "punchline.signaling.Credentials")
	proto.RegisterType((*RelatedAddress)(nil), "punchline.signaling.RelatedAddress")
	proto.RegisterType((*Candidate)(nil), "punchline.signaling.Candidate")
}

func init() { proto.RegisterFile("api/signaling/v1/signaling.proto", fileDescriptor_db5d6de783d80978) }

var fileDescriptor_db5d6de783d80978 = []byte{
	// 886 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x45, 0x59, 0x12, 0x47, 0xb6, 0xbc, 0xd9, 0xba, 0x00, 0x61, 0xb8, 0x82, 0xa0, 0xb6,
	0x80, 0xe1, 0x02, 0x52, 0xeb, 0x06, 0xee, 0xa5, 0x28, 0xa0, 0x90, 0xeb, 0x46, 0x88, 0x4c, 0x11,
	0x4b, 0x2a, 0x69, 0x7a, 0x11, 0x28, 0x72, 0x23, 0x13, 0x95, 0x97, 0x2c, 0xb9, 0x6a, 0xa0, 0xb7,
	0xe8, 0xa1, 0xaf, 0x92, 0x77, 0xe8, 0x31, 0xc7, 0x1e, 0x0b, 0xfb, 0x45, 0x0a, 0xae, 0xfe, 0xa8,
	0x80, 0x31, 0xd0, 0xdc, 0x66, 0x76, 0xe7, 0xfb, 0x38, 0xf3, 0xcd, 0xec, 0x10, 0xda, 0x5e, 0x1c,
	0xf6, 0xd2, 0x70, 0xc6, 0xbd, 0x79, 0xc8, 0x67, 0xbd, 0x3f, 0xbe, 0xdb, 0x39, 0xdd, 0x38, 0x89,
	0x44, 0x84, 0x3f, 0x8b, 0x17, 0xdc, 0xbf, 0x9d, 0x87, 0x9c, 0x75, 0xb7, 0x57, 0x9d, 0x77, 0x0a,
	0xd4, 0x6e, 0x58, 0x9a, 0x7a, 0x33, 0x86, 0x4f, 0xe0, 0x40, 0x44, 0x71, 0xe8, 0xeb, 0x4a, 0x5b,
	0x39, 0xd7, 0xe8, 0xca, 0xc1, 0x18, 0x2a, 0x81, 0x27, 0x3c, 0xbd, 0xdc, 0x56, 0xce, 0x0f, 0xa9,
	0xb4, 0xf1, 0x8f, 0xa0, 0xf9, 0x1e, 0x0f, 0xc2, 0xc0, 0x13, 0x4c, 0x57, 0xdb, 0xca, 0x79, 0xe3,
	0xb2, 0xd5, 0x2d, 0xa0, 0xef, 0x1a, 0x9b, 0x28, 0xba, 0x03, 0xe0, 0x67, 0xd0, 0xf0, 0x13, 0x16,
	0x30, 0x2e, 0x42, 0x6f, 0x9e, 0xea, 0x15, 0x89, 0x6f, 0x17, 0xe3, 0x77, 0x71, 0x34, 0x0f, 0xea,
	0xfc, 0xa5, 0x40, 0xd3, 0x5e, 0x4c, 0xe7, 0x61, 0x7a, 0x4b, 0xd9, 0xef, 0x0b, 0x96, 0x8a, 0x8f,
	0xa4, 0x7f, 0x0a, 0xf5, 0xdb, 0x28, 0x15, 0xdc, 0xbb, 0x63, 0xb2, 0x04, 0x8d, 0x6e, 0xfd, 0x6d,
	0x69, 0xea, 0xc7, 0x4a, 0xab, 0xfc, 0xcf, 0xd2, 0x3a, 0x4f, 0xe0, 0x78, 0x9b, 0x55, 0x1a, 0x47,
	0x3c, 0x65, 0x1d, 0x13, 0x90, 0xb3, 0x98, 0xa6, 0x7e, 0x12, 0x4e, 0xd9, 0x27, 0xa7, 0xda, 0x71,
	0xa1, 0x91, 0xd3, 0x22, 0x23, 0x58, 0xbc, 0x49, 0xbc, 0xd9, 0x86, 0x40, 0x3a, 0x18, 0x81, 0x1a,
	0xbf, 0x0d, 0xd6, 0xd8, 0xcc, 0xc4, 0x5f, 0x00, 0x70, 0xc6, 0x82, 0x49, 0x26, 0x5d, 0x2a, 0xeb,
	0xac, 0x53, 0x2d, 0x3b, 0xc9, 0xc8, 0xd2, 0xce, 0x4f, 0xd0, 0xa4, 0x6c, 0xee, 0x09, 0x16, 0xf4,
	0x83, 0x20, 0x61, 0x69, 0x8a, 0x75, 0xa8, 0x79, 0x2b, 0x73, 0x4d, 0xbd, 0x71, 0x33, 0xb1, 0xe2,
	0x28, 0x11, 0x92, 0xfd, 0x80, 0x4a, 0xbb, 0x73, 0xaf, 0x82, 0xb6, 0xd5, 0x01, 0x5f, 0x41, 0x45,
	0x2c, 0x63, 0x26, 0x81, 0xcd, 0xcb, 0xce, 0xe3, 0xaa, 0xb9, 0xcb, 0x98, 0x51, 0x19, 0x8f, 0x0d,
	0x38, 0xe4, 0x4c, 0xbc, 0x8d, 0x92, 0xdf, 0x26, 0x12, 0x5f, 0x96, 0xf8, 0xe2, 0x81, 0xb0, 0x56,
	0x81, 0x12, 0xdd, 0xe0, 0x3b, 0x07, 0xff, 0x00, 0x75, 0xe1, 0xc7, 0x2b, 0x02, 0x55, 0x12, 0x9c,
	0x15, 0x12, 0xb8, 0x86, 0x2d, 0xc1, 0x35, 0xe1, 0xc7, 0x12, 0xd8, 0x02, 0x78, 0x13, 0x2d, 0x78,
	0xe0, 0x89, 0x30, 0xe2, 0xb2, 0xe3, 0x1a, 0xcd, 0x9d, 0xe0, 0x33, 0xd0, 0xfc, 0xe8, 0x2e, 0x8e,
	0x38, 0xe3, 0x42, 0x3f, 0x90, 0xc5, 0xef, 0x0e, 0xb2, 0x9e, 0xc5, 0x49, 0x18, 0x25, 0xa1, 0x58,
	0xea, 0x55, 0x79, 0xb9, 0xf5, 0xf3, 0x5a, 0xd6, 0x8a, 0xb5, 0xac, 0xef, 0xb4, 0xc4, 0x43, 0x38,
	0x4e, 0x56, 0xbd, 0x98, 0x6c, 0x50, 0x9a, 0x1c, 0xbf, 0x2f, 0x0b, 0xeb, 0xd8, 0xef, 0x1b, 0x6d,
	0x26, 0xfb, 0x7d, 0x1c, 0x80, 0x3c, 0x59, 0x4e, 0xe4, 0xdb, 0xf7, 0xa3, 0xb9, 0x0e, 0x8f, 0x74,
	0x25, 0x23, 0x5b, 0xda, 0xeb, 0x48, 0x7a, 0x94, 0xe4, 0xdd, 0x8b, 0x18, 0x8e, 0x8d, 0x88, 0x73,
	0xe6, 0x67, 0x72, 0x38, 0x22, 0xeb, 0x74, 0x0d, 0x54, 0x8b, 0xbc, 0x42, 0x25, 0x7c, 0x08, 0x75,
	0xe3, 0x39, 0x31, 0x5e, 0x0c, 0xac, 0x9f, 0x91, 0x82, 0x8f, 0x40, 0x33, 0x46, 0x96, 0x45, 0x0c,
	0x97, 0x98, 0xa8, 0xbc, 0x72, 0x6f, 0xec, 0x21, 0xc9, 0x5c, 0x15, 0x03, 0x54, 0xaf, 0xfb, 0x83,
	0x21, 0x31, 0x51, 0x05, 0x23, 0x38, 0x34, 0x07, 0xce, 0x2e, 0xf8, 0x20, 0xbb, 0x35, 0x86, 0x23,
	0x87, 0x98, 0xa8, 0x7a, 0xc1, 0xe1, 0x68, 0x6f, 0x4e, 0x70, 0x0b, 0x4e, 0xc7, 0x96, 0x63, 0x13,
	0x63, 0x70, 0x3d, 0x20, 0xe6, 0xc4, 0xe8, 0x5b, 0xe6, 0xc0, 0xec, 0xbb, 0x64, 0xe2, 0xbe, 0xb6,
	0x09, 0x2a, 0xe1, 0x3a, 0x54, 0x9e, 0x8f, 0x1c, 0x17, 0x29, 0xf8, 0x04, 0x90, 0x43, 0xe8, 0x4b,
	0x42, 0x27, 0x94, 0x5c, 0x0f, 0xc9, 0x2f, 0x83, 0x97, 0x04, 0x95, 0x31, 0x86, 0xa6, 0x4d, 0xf6,
	0xce, 0x54, 0xac, 0xc1, 0x01, 0x25, 0xc3, 0xfe, 0x6b, 0x54, 0xb9, 0x70, 0xa0, 0x91, 0x9b, 0x2b,
	0x7c, 0x06, 0x7a, 0xfe, 0x6b, 0x16, 0x71, 0x5f, 0x8d, 0xe8, 0x8b, 0xdc, 0xb7, 0xc6, 0xa6, 0xfd,
	0x14, 0x29, 0x6b, 0xeb, 0x0a, 0x95, 0x33, 0xcb, 0x35, 0xec, 0xa7, 0x48, 0x5d, 0x5b, 0x57, 0x92,
	0xb4, 0xb6, 0x9e, 0x35, 0xac, 0xc3, 0x49, 0x9e, 0xd0, 0x35, 0xec, 0x0d, 0x19, 0x40, 0xb5, 0x6f,
	0xb8, 0x59, 0x42, 0x0a, 0x6e, 0x40, 0xcd, 0xee, 0x3b, 0xce, 0x2a, 0xe3, 0xcf, 0xe1, 0x89, 0x33,
	0xb8, 0x19, 0x0f, 0xdd, 0xbe, 0x45, 0x46, 0x63, 0x67, 0x32, 0xb2, 0x89, 0x85, 0xd4, 0x0b, 0x17,
	0x8e, 0xf6, 0x7a, 0xf5, 0xa1, 0x32, 0xb2, 0xa2, 0x89, 0x4d, 0x47, 0xee, 0xc8, 0x18, 0x0d, 0x51,
	0x29, 0xeb, 0xd4, 0xd8, 0xb4, 0x91, 0x92, 0x19, 0xae, 0x61, 0xa3, 0xb2, 0x34, 0x86, 0xce, 0x2a,
	0x55, 0x33, 0xb3, 0x2a, 0x97, 0xef, 0x14, 0xd0, 0x9c, 0xcd, 0x30, 0x60, 0x17, 0x6a, 0xeb, 0x1d,
	0x86, 0x8b, 0x47, 0x6f, 0x7f, 0xef, 0x9e, 0x7e, 0xf5, 0x78, 0xd0, 0x6a, 0x0d, 0x62, 0x0a, 0xda,
	0x76, 0x0d, 0xe2, 0xaf, 0x0b, 0x21, 0x1f, 0xae, 0xc9, 0xd3, 0xe2, 0x17, 0xbc, 0xfe, 0x5d, 0x7d,
	0xab, 0x3c, 0x23, 0x7f, 0xdf, 0xb7, 0x94, 0xf7, 0xf7, 0x2d, 0xe5, 0xdf, 0xfb, 0x96, 0xf2, 0xe7,
	0x43, 0xab, 0xf4, 0xfe, 0xa1, 0x55, 0xfa, 0xe7, 0xa1, 0x55, 0xfa, 0xf5, 0x9b, 0x59, 0x28, 0x6e,
	0x17, 0xd3, 0xae, 0x1f, 0xdd, 0xf5, 0xfc, 0x28, 0x4d, 0x05, 0xf3, 0xee, 0x7a, 0x5b, 0xb2, 0xde,
	0xde, 0xbf, 0x72, 0x5a, 0x95, 0x6f, 0xe4, 0xfb, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x16, 0x67,
	0xea, 0xfc, 0x43, 0x07, 0x00, 0x00,
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Credentials != nil {
		{
			size, err := m.Credentials.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignaling(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Candidate != nil {
		{
			size, err := m.Candidate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignaling(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Candidate != nil {
		{
			size, err := m.Candidate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignaling(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SubscribeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Credentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NeedCreds {
		i--
		if m.NeedCreds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Pwd) > 0 {
		i -= len(m.Pwd)
		copy(dAtA[i:], m.Pwd)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Pwd)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ufrag) > 0 {
		i -= len(m.Ufrag)
		copy(dAtA[i:], m.Ufrag)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Ufrag)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RelatedAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelatedAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelatedAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Candidate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Candidate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Candidate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RelayProtocol != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.RelayProtocol))
		i--
		dAtA[i] = 0x50
	}
	if m.RelatedAddress != nil {
		{
			size, err := m.RelatedAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignaling(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Port != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Priority != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x30
	}
	if m.Component != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.Component))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Foundation) > 0 {
		i -= len(m.Foundation)
		copy(dAtA[i:], m.Foundation)
		i = encodeVarintSignaling(dAtA, i, uint64(len(m.Foundation)))
		i--
		dAtA[i] = 0x22
	}
	if m.TcpType != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.TcpType))
		i--
		dAtA[i] = 0x18
	}
	if m.NetworkType != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.NetworkType))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintSignaling(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSignaling(dAtA []byte, offset int, v uint64) int {
	offset -= sovSignaling(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.Candidate != nil {
		l = m.Candidate.Size()
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovSignaling(uint64(l))
	}
	return n
}

func (m *PublishRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.Candidate != nil {
		l = m.Candidate.Size()
		n += 1 + l + sovSignaling(uint64(l))
	}
	return n
}

func (m *PublishResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SubscribeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	return n
}

func (m *Credentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ufrag)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	l = len(m.Pwd)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.NeedCreds {
		n += 2
	}
	return n
}

func (m *RelatedAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovSignaling(uint64(m.Port))
	}
	return n
}

func (m *Candidate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovSignaling(uint64(m.Type))
	}
	if m.NetworkType != 0 {
		n += 1 + sovSignaling(uint64(m.NetworkType))
	}
	if m.TcpType != 0 {
		n += 1 + sovSignaling(uint64(m.TcpType))
	}
	l = len(m.Foundation)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.Component != 0 {
		n += 1 + sovSignaling(uint64(m.Component))
	}
	if m.Priority != 0 {
		n += 1 + sovSignaling(uint64(m.Priority))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovSignaling(uint64(m.Port))
	}
	if m.RelatedAddress != nil {
		l = m.RelatedAddress.Size()
		n += 1 + l + sovSignaling(uint64(l))
	}
	if m.RelayProtocol != 0 {
		n += 1 + sovSignaling(uint64(m.RelayProtocol))
	}
	return n
}

func sovSignaling(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSignaling(x uint64) (n int) {
	return sovSignaling(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Candidate == nil {
				m.Candidate = &Candidate{}
			}
			if err := m.Candidate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &Credentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Candidate == nil {
				m.Candidate = &Candidate{}
			}
			if err := m.Candidate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ufrag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ufrag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedCreds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedCreds = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelatedAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Candidate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Candidate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Candidate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CandidateType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkType", wireType)
			}
			m.NetworkType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkType |= NetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpType", wireType)
			}
			m.TcpType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcpType |= TCPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Foundation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Foundation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			m.Component = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Component |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignaling
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignaling
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RelatedAddress == nil {
				m.RelatedAddress = &RelatedAddress{}
			}
			if err := m.RelatedAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayProtocol", wireType)
			}
			m.RelayProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayProtocol |= RelayProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSignaling(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignaling
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSignaling(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSignaling
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSignaling
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSignaling
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSignaling
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSignaling
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSignaling        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSignaling          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSignaling = fmt.Errorf("proto: unexpected end of group")
)
